from typing import ClassVar, Self

class Control:
    ESC: ClassVar[Control] = ...
    APC: ClassVar[Control] = ...
    CSI: ClassVar[Control] = ...
    DCS: ClassVar[Control] = ...
    OSC: ClassVar[Control] = ...
    PM: ClassVar[Control] = ...
    SOS: ClassVar[Control] = ...
    BEL: ClassVar[Control] = ...
    ST: ClassVar[Control] = ...

    @staticmethod
    def is_sequence_start(byte: int) -> bool: ...

    def is_escape(self) -> bool: ...
    def is_terminator(self) -> bool: ...
    def is_function(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...


class Action:
    Print: ClassVar[Action] = ...
    Start: ClassVar[Action] = ...
    Ignore: ClassVar[Action] = ...
    Execute: ClassVar[Action] = ...
    Retain: ClassVar[Action] = ...
    DispatchApc: ClassVar[Action] = ...
    DispatchCsi: ClassVar[Action] = ...
    DispatchDcs: ClassVar[Action] = ...
    DispatchEsc: ClassVar[Action] = ...
    DispatchOsc: ClassVar[Action] = ...
    DispatchPm: ClassVar[Action] = ...
    DispatchSos: ClassVar[Action] = ...

    def is_print(self) -> bool: ...
    def is_start(self) -> bool: ...
    def is_retained(self) -> bool: ...
    def is_dispatch(self) -> bool: ...
    def control(self) -> None | Control: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...


class VtScanner:
    def __new__(cls, capacity: int = ...) -> Self: ...
    def reset(self) -> None: ...
    def capacity(self) -> int: ...
    def step(self, byte: int) -> Action: ...
    def last_byte(self) -> int: ...
    def is_empty(self) -> bool: ...
    def len(self) -> int: ...
    def did_overflow(self) -> bool: ...
    def did_abort(self) -> bool: ...
    def did_complete(self) -> bool: ...
    def completed_control(self) -> None | Control: ...
    def completed_bytes(self) -> bytes: ...
    def completed_string(self) -> str: ...
